```{r include_packages_2, include = FALSE}
# This chunk ensures that the thesisdown package is
# installed and loaded. This thesisdown package includes
# the template files for the thesis and also two functions
# used for labeling and referencing
#opts_chunk$set(cache=TRUE)

if(!require(devtools))
  install.packages("devtools", repos = "http://cran.rstudio.com")
if(!require(dplyr))
  install.packages("dplyr", repos = "http://cran.rstudio.com")
if(!require(ggplot2))
  install.packages("ggplot2", repos = "http://cran.rstudio.com")
if(!require(ggplot2))
  install.packages("bookdown", repos = "http://cran.rstudio.com")
if(!require(thesisdown)){
  library(devtools)
  devtools::install_github("ismayc/thesisdown")
}
library(thesisdown)
library(data.table)
library(pcadapt)
library(EILA)
library(simulate)
```

# Introgression adaptative

## Qu'est-ce que l'introgression ?

Avant de s'intéresser à la notion d'introgression, intéressons-nous d'abord à
celle d'hybridation. L'hybridation peut être définie comme la reproduction
entre deux individus appartenant à deux espèces ou à deux populations différentes.
Cette définition nous amène à nous poser deux questions. La première, relative à la notion d'espèce, est souvent sujette à controverse. La seconde concerne quant à elle la désignation de populations différentes. Qu'est-ce qui fait que deux groupes d'individus sont différents ? Harrison suggère en 1990 que deux individus issus de populations différentes doivent chacun posséder des traits héritables qui les différencient [@harrison1990hybrid]. 

Nous parlons d'introgression lorsqu'un certain nombre de gènes est transféré
d'une population à une autre.

## Coefficients de métissage globaux et locaux

Étant données des populations ancestrales, il est possible d'estimer pour un
individu donné, la proportion de son génôme provenant de chacune des populations
ancestrales. Ces proportions sont connues plus communément sous le nom de 
*coefficients de métissage globaux*. De nombreux logiciels existent pour 
l'estimation de ces coefficients : STRUCTURE, ADMIXTURE [@alexander2009fast], LEA [@frichot2015lea], tess3r [@caye2016tess3]. 
En complément à cette information globale, 
il peut être intéressant de déterminer sur des portions plus petites du génôme, 
de la même manière que dans le cas global, les proportions venant de telle ou 
telle population ancestrale pour chacune de ces portions. Nous parlons dans ce 
cas de *coefficients de métissage locaux*. Encore une fois, plusieurs logiciels 
ont été proposés dans le but d'estimer ces coefficients : Hapmix [@price2009sensitive], 
EILA [@yang2013efficient], LAMP [@thornton2014local], loter ou encore RFmix [@maples2013rfmix].

## Introgression

L'introgression peut être détectée de différentes façons. Une première approche
consiste à utiliser les *coefficients de métissage locaux*. Les méthodes 
mentionnées plus haut estiment ces coefficients pour chaque individu, permettant
de calculer à partir de ceux-ci des coefficients de métissage locaux pour chaque
population.

## Lien entre Analyse en Composantes Principales et métissage global.

L'un des premiers articles à établir un lien entre l'ACP et les coefficients
de métissage global fut sur l'interprétation généalogique de l'ACP de Gil McVean 
[@mcvean2009genealogical]: 

```{r mcvean, results="asis", echo=FALSE, fig.cap="Coefficients de métissage et ACP", out.width = "200px", fig.align='center'}
include_graphics("figure/mcvean.png")
```

Pour chacun des 22 chromosomes, 

## Analyse en Composantes Principales locale

Notant $p$ le nombre de marqueurs génétiques, $i$ un entier compris entre
$1$ et $p$, et $x_i$ la position génétique (en Morgans) ou la position physique 
(en paires de bases) du $i$-ème marqueur génétique. Nous définissons pour cet 
entier $i$ la fenêtre $W_i^T$ de taille $T$ et centrée en $i$ :

$$W_i^T = \{ j \in [|1, p|], |x_i - x_j| \leq T/2 \}$$

## Sensibilité à l'imputation des données manquantes

## Simulations

### Données de peupliers

Le premier jeu de données est issu d'une étude d'introgression adaptative chez
les peupliers d'Amérique du Nord [@suarez2016]. La simulation d'haplotypes d'individus
admixés est effectuée à partir des deux populations ancestrales qui y sont 
présentes. La première, *Populus Balsamifera*, est une espèce de peupliers
qui peuple le nord du continent nord-américain, d'Est en Ouest, et se trouve
exposée à des conditions climatiques peu clémentes.
La seconde, *Populus Trichocarpa*, est principalement localisée en Californie,
et bénéficie d'un climat continental.

Chacune des simulations est constituée de $50$ haplotypes de la souche continentale,
de $50$ haplotyêpes de la souche boréale, ainsi que de $50$ haplotypes d'individus
hybrides générés à partir des haplotypes ancestraux. Ces haplotypes ancestraux
ont été estimés à l'aide du logiciel Beagle.
\'A partir des positions en paires de base, une carte de recombinaison génétique
est générée en utilisant le taux de recombinaison moyen chez le peuplier. Le taux
de recombinaison, noté $\tau_r$, correspond au nombre moyen de paires de bases à
parcourir pour qu'ait lieu un épisode de recombinaison génétique, *i.e.*, notant
$L$ la longueur du chromosome en Morgans ($M$), et $N_{bp}$ le nombre de paires
de bases le constituant, le taux de recombinaison génétique pour ce chromosome est
donné par la relation:

$$\tau_r = \frac{L}{N_{bp}}$$ 

Dans ce scénario, les simulations ont été produites en utilisant un taux de recombinaison génétique moyen $\tau_r$
de $0.05$ centiMorgans par million de paire de bases, correspondant à la valeur utilisée par les auteurs de l'étude
avec le logiciel RASPberry (\textit{Recombination via Ancestry Switch Probability}). A partir de la donnée de la position
physique en paires de bases ainsi que du taux de recombinaison moyen, nous générons une carte de recombinaison
génétique adaptée à nos simulations.

### Génération aléatoire d'individus hybrides

Pour simuler un individu métissé, il est d'abord nécessaire de simuler l'emplacement des évènements
de recombinaison. Pour ce faire, nous utilisons le modèle décrit dans [@price2009sensitive], en parcourant


```{r lambda0001, echo = FALSE, out.width = "400px", out.height="200px", fig.align = 'center', fig.cap="$\\lambda = 0.001$"}
include_graphics(path = "figure/ancestry_heatmap_lambda_0001.png")
```
```{r lambda001, echo = FALSE, out.width = "400px", out.height="200px", fig.align = 'center', fig.cap="$\\lambda = 0.01$"}
include_graphics(path = "figure/ancestry_heatmap_lambda_001.png")
```
```{r lambda01, echo = FALSE, out.width = "400px", out.height="200px", fig.align = 'center', fig.cap="$\\lambda = 0.1$"}
include_graphics(path = "figure/ancestry_heatmap_lambda_01.png")
```


```{r simulations}
path <- "~/Documents/thesis/git/simulations/introgression/"
output.name <- "populus"
recombinationRate <- 0.05 # in Morgans per Megabase
nSNP <- 50000
ancstrl.1 <- 1
ancstrl.2 <- 3
hyb <- 4
intro.size <- 500
global.ancestry <- 0.1
inverted.ancestry <- 0.5

info.map <- as.matrix(fread(paste0(path, output.name, ".map"), 
                            data.table = FALSE))
H1 <- as.matrix(fread(paste0(path, output.name, "_H1"), 
                      data.table = FALSE))
H2 <- as.matrix(fread(paste0(path, output.name, "_H2"), 
                      data.table = FALSE))
n.hyb <- ncol(H1) / 2 

### Introgression region
idx <- sample(1:nSNP, size = 1)
beg.reg <- max(1, idx - intro.size)
end.reg <- min(nSNP, idx + intro.size)
intro.reg <- beg.reg:end.reg
```

\newpage


```{r, eval = FALSE, echo = FALSE, fig.width = 7, fig.height = 4, fig.align = 'center', fig.cap = "$\\lambda = 0.1$"}
lambda <- 0.1
res <- simulate::generate_hybrid_matrix(H1, 
                                        H2, 
                                        alpha = global.ancestry, 
                                        beta = inverted.ancestry, 
                                        n.hyb = n.hyb,
                                        gen_map = info.map[, 2], 
                                        lambda = lambda, 
                                        ancestry.switch = intro.reg)
simulate::display.ancestry(res$true.ancestry.matrix)
im <- matrix(0, ncol = ncol(res$true.ancestry.matrix), nrow = nrow(res$true.ancestry.matrix))
im[res$true.ancestry.matrix == "22"] <- 2
im[res$true.ancestry.matrix %in% c("12", "21")] <- 1
im[res$true.ancestry.matrix == "11"] <- 0
image(im, axes = FALSE, xlab = "", ylab = "")
```

```{r, eval = FALSE, echo = FALSE, fig.width = 7, fig.height = 4, fig.align = 'center', fig.cap = "$\\lambda = 10$"}
lambda <- 10
res <- simulate::generate_hybrid_matrix(H1, 
                                        H2, 
                                        alpha = global.ancestry, 
                                        beta = inverted.ancestry, 
                                        n.hyb = n.hyb,
                                        gen_map = info.map[, 2], 
                                        lambda = lambda, 
                                        ancestry.switch = intro.reg)
simulate::display.ancestry(res$true.ancestry.matrix)
im <- matrix(0, ncol = ncol(res$true.ancestry.matrix), nrow = nrow(res$true.ancestry.matrix))
im[res$true.ancestry.matrix == "22"] <- 2
im[res$true.ancestry.matrix %in% c("12", "21")] <- 1
im[res$true.ancestry.matrix == "11"] <- 0
image(im, axes = FALSE, xlab = "", ylab = "")
```


```{r, eval = FALSE, echo = FALSE, fig.width = 7, fig.height = 4, fig.align = 'center', fig.cap = "$\\lambda = 50$"}
lambda <- 50
res <- simulate::generate_hybrid_matrix(H1, 
                                        H2, 
                                        alpha = global.ancestry, 
                                        beta = inverted.ancestry, 
                                        n.hyb = n.hyb,
                                        gen_map = info.map[, 2], 
                                        lambda = lambda, 
                                        ancestry.switch = intro.reg)
simulate::display.ancestry(res$true.ancestry.matrix)
im <- matrix(0, ncol = ncol(res$true.ancestry.matrix), nrow = nrow(res$true.ancestry.matrix))
im[res$true.ancestry.matrix == "22"] <- 2
im[res$true.ancestry.matrix %in% c("12", "21")] <- 1
im[res$true.ancestry.matrix == "11"] <- 0
image(im, axes = FALSE, xlab = "", ylab = "")
```

\newpage

### Méthodes de détection

#### Etat de l'art

##### Scénario à flux de gènes

###### La statistique D de Pattersion

###### RNDmin

###### BDF

##### Scénario de métissage



##### Analyse Linéaire Discriminante

#### Régression linéaire, régression logistique, forêts aléatoires et importance des variables

#### Régression locale, package mgcv, locfit, Backward selection strategy

#### ACP locale et espace de formes


### Résultats de la comparaison des logiciels

Dans ce paragraphe, nous allons comparer notre statistique de test à un ensemble de statistiques implémentées dans le package R *PopGenome* : la statistique $D$ de Patterson, RNDmin [@rosenzweig2016powerful] et BDF [@pfeifer2017estimates].

### Simulations à partir de ms et Seq-Gen

FIGURE AVEC LES DIFFERENTS ARBRES P1, P2, P3 ET O

Décortiquons la ligne de commande *ms* permettant de générer les séquences de 
nucléotides.

```
./ms 200 1 -I 4 50 50 50 50 -ej 1 2 1 -ej 2 3 1 -ej 3 4 1 
-es 0.1 2 0.8 -ej 0.1 5 3 -r 50 5000 -T #background model
```

- 200 : nombre d'individus.

- 4 : nombre de populations dans lesquelles se répartissent les individus.

- 50 50 50 50 : répartition des individus dans chacune des populations.

- -ej 1 2 1 : 1 unité de temps auparavant, la population 2 fusionne avec la 
population 1.

- -ej 2 3 1 : 2 unités de temps auparavant, la population 3 fusionne avec la 
population 1 (qui est désormais composée des populations 1 et 2).

- -ej 3 4 1 : 3 unités de temps auparavant, la population 4 fusionne avec la 
population 1 (constituée des populations 1, 2 et 3).

- -es 0.1 2 0.8 : 0.1 unité de temps auparavant, la population 2 perd une partie
de ses individus en faveur d'une population autre que celles déjà présentes (population 5).
Pour chaque individu initialement présent dans la population 2, sa probabilité d'y
rester est 0.80.

- -ej 0.1 5 3 : 0.1 unité de temps auparavant, la population 5 fusionne avec la 
population 3.

Pour utiliser *ms*, il faut définir les évènements depuis le temps présent. Pour
comprendre le scénario démographique, il est plus aisé de reprendre les évènements 
dans l'ordre chronologique.

```{r alternate, results="asis", echo=FALSE, fig.cap="Alternate model", out.extra="scale=0.5"}
include_graphics("figure/alternate.pdf")
```

Nous observons sur la figure \@ref(fig:alternate),
